
# Общие слова о языке C++

Произошел от языка С.
Почти любая программа на C будет корректна на C++.
Версии языка:
- C++98
- C++03
- C++11
- C++14
- C++17
- C++20
- C++23

# Типы переменных. Статическая и динамическая типизация

## Типизация

_Статическая типизация_ - все типы должны быть известны на моменте компиляции, нельзя в `RunTime` менять типы переменных. 
(Ex.: C++)

_Динамическая типизация_ - возможно менять типы переменных в `RunTime`. 
(Ex.: Python)

## Фундаментальные типы

### Целочисленные типы

Integral types:

1. `int` (4 байта) 
```
[-2^31; 2^31 - 1]
2'147'483'648
```
1. `long` (4 байта)
2. `long long` (8 байт)
3. `short` (2 байта)
4. `char` (1 байт)
5. `size_t` - беззнаковый целочисленный тип, который достаточен для того, чтобы индексировать всю оперативную память, любую ячейку в массиве.

Занимаемая память, регламентрирумая стандартом, говорит, что int должен быть хотя бы 2 байта, но практически на всех устройствах будет рассматриваться как 4 байта. Не гарантируется, что они занимают написанное выше количество байт.

Про каждый из этих типов можно сказать `unsigned`,  диапазон сдвигается. 

Типы с фиксированной шириной: 
1. `int8_t`
2. `int16_t`
3. `int32_t`
4. `int64_t`

Также можно делать их беззнаковыми: `uint16_t`, `uint32_t` и тд.

`std::byte` - с C++17, по семантике тоже самое, как однобайтый int.

`bool` - неявно конвертируется в `int`. Занимает 1 байт. 
(байт - минимальная ячейка памяти)

### Типы с плавающей точкой

Floating point types:
1. `float` (4 байта)
2. `double` (8 байт)
3. `long double` (8/16 байт)

Как хранятся числа с плавающей точкой? Есть _мантиса_ (биты, кодирующие числовое значение) и _экспонента_ (степень двойки, на которую нужно умножить мантису).
Это приводит к тому, что чем больше число по модулю, тем больше дискретность. Например, мы можем в `double` закодировать 
```
0, 000'000'1
```
и не можем
```
1'000'000, 000'000'1
```

Любое число в `double` конвертируется в `int` без потери точности.


## Классовые типы

`std::string` - позволяет хранить строки и работать с ними.
Имеют операторы сравнения.

```cpp
// инициализация
std::string s = "abc";

// индексация
operator[](size_t);
```

_null-terminated strings_ - строки из C, оканчивающиеся символом с кодом 0.
Чтобы сохранить совместимость с C, в C++ это также работает.

```cpp
std::string s = "abc";
s[3] // символ с кодом 0
s[4] // UB
```

_UB_ - undefined behavior (неопределенное поведение). 
Это не гарантированная ошибка (`s[4] // UB`), так как мы не хотим тратить время. 
Один из принципов C++ - эффективность дороже безопасности. Язык спроектирован так, чтобы быть очень быстрым в исполнении в ущерб безопасности.

```cpp
.at(size_t) // обращение по индексу с проверкой, если обратимся за пределы допустимого, то вылетит error out_of_range
```

```cpp
+  // конкатенация строк
+=
push_back(char)
pop_back()
front() // обращение к первому символу с возможностью присваевания
back()
size()
shrink_to_fit()
clear()
reserve(size_t)
resize(size_t, char)
```

---

`std::vector<type>` - динамический (расширяющийся по мере надобности) массив
Имеют операторы сравнения.

```cpp
operator[](size_t)
push_back(size_t)
pop_back()
front()
back()
shrink_to_fit() // C++11
clear() // чистит vector, но не чистит память
reserve(size_t) // предвыделяем память
resize(size_t, char)
capacity()
```

`push_back` работает за `O(1) амортизированное`. Это значит, что 
суммарное время, затраченное на операции, деленное на количество операций будет стремится к единице. Но при этом отдельно взятый `push_back` в худшем случае может работать за линейное время.

---

`std::list` - двувязный список
`std::forward_list` - односвязный список
`std::deque` - двусторонняя очередь
`std::stack` - явлется адаптером над контейнером, неполноценный класс сам по себе, хранит внутри `std::deque` (по умолчанию), по сути надстройка, интерфейс доступа к деку (или вектору)
`std::queue`
`std::priority_queue`

--- 

Ассоциативные контейнеры:
1. `std::map<std::string, int>` - хранит пары {key - value}, элементы хранятся возрастания
операции работают за `O(logn)`, так как `map` работает на красно-черном дереве
```cpp
operator[](key) // обращение по ключу, если значения нет, то создастся пара по ключу со значением по умолчанию
.at(key) // если ключа нет, кинет исключение
find(key)
insert(pair<key, value>)
erase(key)
size()
```
`map` не может хранить пары с одинаковыми ключами, а 
`std::multimap` может это делать (но нельзя делать `operator[]` и `.at()` ).
```cpp
lower_bound(key)
upper_bound(key)
```

`std::set`
В отличие от `std::map`, хранятся только значения, причем упорядоченные.

`std::unordered_map` - неупорядоченная ассоциативная структура данных, хранящая также. как и `map`, пары (ключ, значение).
Вставка, поиск и удаление работают в среднем за `O(1)`, благодаря работе на hash таблице. 

В чем разница между  `в среднем за O(1)` и `амортизированно за O(1)`?
В среднем имеется ввиду по входным данным. То есть в среднем по всевозможным наборам входных данных.

`std::unordered_multiset`, `std::unordered_multimap` аналогично.


## Потоки `std::istream` и `std::ostream`

```cpp
std::cout << x;
```

`std::istream` - входной поток
`std::ostream` - поток на выход

`std::cin` и `std::cout` - глобальные переменные типов `std::istream` и `std::ostream` соответственно. У этих типов опередены операторы `>>` и `<<`.

`std::ifstream` - ввод в файл
`std::ofstream` - вывод из файла

`std::istringstream` - трактуем строку как поток (происходит `push_back` в строку)
`std::ostringstream`