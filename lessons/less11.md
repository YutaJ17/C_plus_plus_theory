Не считая неявного приведения, есть:
1. C-style cast
2. static cast
3. dynamic cast
4. reinterpret cast 
5. const cast

## static cast

Если нужно сделать приведение типа, но нет уверенности какое из, то нужно делать `static cast`.
```cpp
int x = 0;
static_cast<double>(x);
```

## reinterpret cast

Можно делать либо к ссылке, либо к указателю.
Способ трактовать биты одной переменной как биты другой переменной.
Его нельзя делать к новому объекту, можно только указателю либо к ссылке, но не к копии.
```cpp
long long y = 1729;
std::cout << reinterpet_cast<double&>(y);  // UB

int x = 0;
int* p = &x;
std::string* str = reinterpet_cast<std::string*>(p);
std::cout << *str;
```
Но мы не можем из константного типа получить константный.

## const cast

Можно делать либо к ссылке, либо к указателю.
```cpp
const int c = 5;
int& cc = const_cast<int&>(c);  // UB
cc = 7;
std::cout << c << ' ' << cc;
```

## C-style cast

```cpp
double d = (double) x;
```
Объединяет вышеперечисленные касты, лучше не использовать.

## dynamic cast

см дальше

# Стадии сборки

1. Препроцессинг
2. Компиляция (.cpp -> .s)
3. Ассемблирование (.s -> .o)
4. Линковка (.o -> .out)
Задача линковщика поставить определения функций в места их вызова.

# Санитайзеры

Специальная программа, которая отлавливает UB, если что-то не так, то программа упадет в `RunTime`. Программа с санитайзерами работает раз в 5-10 дольше. 
Есть разные санитайзеры: address, undefined, lick.

