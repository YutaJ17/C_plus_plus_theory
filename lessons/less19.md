
## Касты при наследовании

```
 Base      (наследование)
  ↑
Derived
```


```
cast:
	Derived -> Base
```

|             | copy (`slicing`) | ptr | ref |
| ----------- | ---------------- | --- | --- |
| implicit    | ok               | ok  | ok  |
| static      | ok               | ok  | ok  |
| reinterpret | CE               | ok  | ok  |

```
cast:
	Base -> Derived
```

|             | copy | ptr              | ref              |
| ----------- | ---- | ---------------- | ---------------- |
| implicit    | CE   | CE               | CE               |
| static      | CE   | OK (possibly UB) | OK (possibly UB) |
| reinterpret | CE   | OK (possibly UB) | OK (possibly UB) |

А если наследование приватное, как это будет работать иначе?


```
cast:
	Derived -> Base
```

|             | copy (`slicing`) | ptr | ref |
| ----------- | ---------------- | --- | --- |
| implicit    | CE               | CE  | CE  |
| static      | CE               | CE  | CE  |
| reinterpret | CE               | ok  | ok  |

```
cast:
	Base -> Derived
```

|             | copy | ptr | ref |
| ----------- | ---- | --- | --- |
| implicit    | CE   | CE  | CE  |
| static      | CE   | CE  | CE  |
| reinterpret | CE   | OK  | OK  |

## Множественное наследование

У класса может быть несколько предков. 
```
int m;   int d;
Mom    Dad
 ↑       ↑
  \     /
   \   /
    Son
	int s;
```

```cpp
class Son : public Mom, public Dad {};
```

Объект `Son s` будет в памяти занимать 12 байт. 
Хранится будут в порядке `m`,  `d`,  `s`.

Если есть функция 
```cpp
void f(Dad& d) {}
```
можно ли сделать `f(s)`?

а вот так:
```cpp
void f(Dad* d) {}
f(&s);
```
Сдвиниться ли адрес на 4, или будет CE? Все сработает.

```cpp
Dad* p = &s;  // пример неявного каста одного pointer к другому, при котором численное значение pointer меняется.
```

Вторая проблема: что если поля называются одинаково?
```cpp
struct Dad {
	void f(int);
};

struct Mom {
	void f(double);
};

struct Son : public Mom, public Dad {};

int main() {
	Son s;
	s.f(1.0);
	s.Dad::f(1);  // можно так
}
```

Проблема ромбовидного наследования (Diamond problem):
```
	int g;
  Granny
    ↑
  /   \
int m;  int d;
Mom   Dad
 ↑     ↑
  \   /
   int s;
   Son
```
Сколько в памяти будет занимать объект сына? 20, так как будет 2 экземляра бабушки.
Более корректная картинка:


```
Granny  Granny
  ↑      ↑
Mom   Dad
 ↑     ↑
  \   /
   Son
```
В памяти: `g`, `m`, `g`, `d`, `s`.
```cpp
Son s;
s.g; // CE
s.Mom::g;  // ok
s.Granny::g;  // CE
```

Что если сделать каст к Granny?
```cpp
Granny& g = s;  // CE: ambiguous cast
static_cast<Mom::Granny&>(s);  // CE
```
Чтобы скаститься к Granny, нужно сначала скаститься к Mom или к Dad, а потом уже к Granny.

Другой пример:
в Granny есть метод f().
```cpp
s.f();
```
Что может пойти не так?
`CE` по причине неоднозначности. 

Другой пример:
```cpp
mom& m = s;
static_cast<Dad&>(m);  // CE 
```

Другой пример:

```
            Granny 
              ↑
              | 
              |                        int g;
             Dad                      Granny
              ↑                          ↑
              |                          | 
              |                          |
              +--------------------------+
                           |
		                  Son
```

Granny одна и та же, просто 2 экземпляра (как в примерах выше).
```cpp
s.Granny::g; // inaccessable base class
```

Другой пример:

```
void f();  void f();
Mom        Dad
 ↑         ↑
  \       /
   |    /
   Son
   void f();
```

можно ли так? (CE)
```cpp
void (Mom::*p)() = &Mom::f;  // указатель на метод мамы
(s.*p)();  // по этому указателю вызываем метод у сына
```
 а если так:  
 ```cpp
void (Dad::*p)() = &Dad::f; 
(s.*p)(); // CE 
```
Указатели на методы устроены сложнее, чем указатели на функции. Указатель на метод занимает 16 байт. 
Поля, с которыми вы собираетесь работать, сдвинуты относительно начала вашего объекта, от которого вы вызвались.
Указатель на метод состоит из двух частей: он хранит непосредственно адрес функции `&f` и сдвиг `shift`. 
В приведенном примере `shift = 4`, хотя в большинстве случаев он равен 0.

## Virtual inheritance

Вирутальное наследование. 

```
	int g;
  Granny
    ↑
  /   \
int m;  int d;
Mom   Dad
 ↑     ↑
  \   /
   int s;
   Son
```
Есть возможность сделать так, чтобы размер объекта `Son s` был 16 байт.

```cpp
struct Mom : public virtual Granny {};
struct Dad : public virtual Granny {};

Son s;
s.g;  
Granny& g = s;  
```

Как это размещается в памяти?
Сколько памяти будет занимать объект `Son s`? Он будет занимать 40 байт.
В памяти:
(`ptr`, `m`)...(`ptr`, `d`)...`s`, `g`...
`ptr` указывают на некоторую специальную структуру данных, которая находится в статической памяти, в которой перечислены сдвиги от начала объекта до всех виртуальных предков. Для мамы, папы и сына будут созданы 3 таблицы, каждому по одной.
```
Mom | 12
Dad | 12
Son | 32
```
Такая таблица называется `vtable`. 

Что произойдет?
 ```cpp
 Granny& g = s;
 static_cast<son&>(g);  // CE, может быть более сложная иерархия
 ```
 `static_cast` не пременим при виртуальном наследовании вниз. Вверх можно, это будет однозначно.

Еще в `vtable` хранится `top offset`. Это число, показывающее насколько текущее положение сдвинуто относительно начала объекта.

Что будет, если унаследовать один класс вируально, а второй нет? Это сработает.  Но снова будет неоднозначность обращений к Granny.

Другой пример:
```
       void f()
    W     V     W
    ↑     ↑     ↑
    │    ╱ ╲    │
    │   ╱   ╲   │
    │  ╱     ╲  │
    ╰─┼       ╰─┼
      ↓         ↓
      B         C
    void f()
      ↑         ↑
      │         │
      ╰─────────╯
          ↓
          A
```
Класс V - виртуально унаследован, класс W - нет.
```cpp
A a;
a.f();  // какой метод выберется?
```
По правилу поиска имен, метод из B должен затмить метод из V. Но тут по одному из путей происходит перекрытие имен, по другому - нет.

Правило скрытия: если хоть по одному из путей имя перекрыто, то остальные пути не будут рассматриваться и выберется именно оно. 

```
void g()      void g()
    W     V     W
    ↑     ↑     ↑
    │    ╱ ╲    │
    │   ╱   ╲   │
    │  ╱     ╲  │
    ╰─┼       ╰─┼
      ↓         ↓
      B         C
    void g()
      ↑         ↑
      │         │
      ╰─────────╯
          ↓
          A
```
А в таком случае при попытке вызвать метод g() будет неоднозначное поведение, CE:
```cpp
A a;
a.g();  // CE
```

Разница между двумя случаями в том, что V - вирутально наследуемо, а W - нет.