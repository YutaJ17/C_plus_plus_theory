
В `local scope`, помимо объявлений, мы можем писать `expressions` (выражения) и `control statements` (управляющие конструкции).

`Statement`(инструкция):
1. `declaration`(объявление новой сущности)
частным случаем является `definition`
2. `expression`(выражения)
3. `control statement`

`;` - специальный символ, обозначающий границу `statement`.
# Expressions

## 1. Ассоциативность операторов

### Левоассоциативные операторы (группируются слева направо)
```cpp
+  -  *  /  %                     // Арифметические
<< >>                             // Битовые сдвиги
|  &  ^                           // Битовые операции
<  >  <=  >=  ==  !=  <=> (C++20) // Сравнения
&&  ||                            // Логические
```

**Пример:** `a - b - c` → `(a - b) - c`

### Правоассоциативные операторы (группируются справа налево)


```cpp
=  +=  -=  *=  /=  %=            // Присваивание
<<=  >>=  &=  |=  ^=             // Составное присваивание
?: (условный оператор)           // Единственный тернарный оператор

```

**Пример:** `a = b = c` → `a = (b = c)`

## 2. Особенности вычисления

### Сокращённое вычисление (short-circuit evaluation)

```cpp
// && — если левый операнд false, правый не вычисляется
if (ptr != nullptr && ptr->value > 0) {
    // ptr->value безопасно, если ptr != nullptr
}

// || — если левый операнд true, правый не вычисляется
if (x < 0 || array[x] == 0) {
    // array[x] вычисляется только если x >= 0
}
```

**Важно:** Это не оптимизация, а гарантия языка. Правый операнд действительно не вычисляется на уровне абстрактной машины C++.

## 3. Категории выражений: `lvalue` и `rvalue`

### Определения

- `lvalue` (left value) — выражение, представляющее объект с идентичностью (имеющий адрес в памяти).
    
- `rvalue` (right value) — выражение, представляющее временное значение или объект без идентичности.
    

### Ключевые различия

|Свойство|lvalue|rvalue|
|---|---|---|
|**Адрес**|Можно взять (`&x`)|Нельзя взять адрес|
|**Присваивание**|Можно присваивать (если не `const`)|Нельзя присваивать|
|**Время жизни**|Длительное (определяется областью видимости)|Временное (до конца full-expression)|

### Примеры

```cpp
// lvalue-выражения
int x = 5;          // x — lvalue
int* p = &x;        // Можно взять адрес
x = 10;             // Можно присваивать
int& r = x;         // r — lvalue-ссылка
arr[0] = 5;         // arr[0] — lvalue

// rvalue-выражения
int y = 10;         // 10 — rvalue (литерал)
y = x + 5;          // (x + 5) — rvalue
int z = func();     // func() — rvalue (если возвращает не ссылку)
```


## 4. Возвращаемые значения операторов

### Операторы, возвращающие `lvalue`

```cpp
// 1. Оператор присваивания (и составного присваивания)
(x = y) = z;        // OK: = возвращает lvalue (ссылку на x)
(a += b) += c;      // OK: += возвращает lvalue

// 2. Оператор индексирования []
arr[5] = 10;        // arr[5] — lvalue

// 3. Оператор разыменования *
*p = 20;            // *p — lvalue

// 4. Условный оператор ?: (при определённых условиях)
int a, b;
(a > b ? a : b) = 100;  // OK: если оба операнда — lvalue одного типа

// 5. Оператор запятая ,
int x, y;
(x = 5, y) = 10;    // (x = 5, y) — lvalue, если y — lvalue

// 6. Оператор доступа через указатель на член ->*
struct S { int x; } obj;
int S::* ptr = &S::x;
(obj.*ptr) = 42;    // obj.*ptr — lvalue

```

### Операторы, возвращающие `rvalue`


```cpp
// Большинство бинарных операторов:
a + b               // Арифметические
a == b              // Сравнения
a && b              // Логические
a << b              // Битовые сдвиги

// Унарные операторы (кроме * и &):
!a                  // Логическое НЕ
~a                  // Битовое НЕ
+a                  // Унарный плюс
-a                  // Унарный минус
```

## 5. Важные уточнения и примеры

### 1. Не все lvalue можно присваивать


```cpp
const int ci = 5;
ci = 10;            // Ошибка! ci — const lvalue
```


### 2. Адрес можно брать только от lvalue

```cpp
int x = 5;
int* p1 = &x;       // OK: x — lvalue
int* p2 = &(x + 1); // Ошибка: (x + 1) — rvalue
```

### 3. Ссылки привязаны к категориям

```cpp
int x = 5;
int& lref = x;      // OK: lvalue-ссылка привязывается к lvalue
int& rref = 10;     // Ошибка: lvalue-ссылка не может привязаться к rvalue

int&& rref2 = 10;   // OK: rvalue-ссылка привязывается к rvalue
int&& rref3 = x;    // Ошибка: rvalue-ссылка не может привязаться к lvalue
```

### 4. Возвращаемое значение функций

cpp
```cpp
int func() { return 42; }      // Возвращает rvalue
int& func_ref() { static int x; return x; } // Возвращает lvalue

func() = 5;         // Ошибка: func() — rvalue
func_ref() = 5;     // OK: func_ref() — lvalue
```

## 6. Практические примеры

### Пример 1: Цепочка присваиваний

```cpp
int a, b, c;
a = b = c = 0;      // Правоассоциативно: a = (b = (c = 0))
```

### Пример 2: Комбинирование операторов

```cpp
int x = 5, y = 3, z = 2;
x += y *= z;        // y *= z → y = y * z = 6, затем x += 6 → x = 11
```


### Пример 3: Безопасный доступ

```cpp
std::vector<int> v;
// Без сокращённого вычисления — небезопасно:
if (v[4] == 1 && v.size() >= 5) { /* UB если size() < 5 */ }

// С правильным порядком — безопасно:
if (v.size() >= 5 && v[4] == 1) { /* v[4] вычисляется только если size() >= 5 */ }
```
### Пример 4: Составное присваивание

```cpp
int x = 5;
(x *= 2) += 3;      // x = 5 * 2 = 10, затем 10 + 3 = 13
cout << x;          // Выведет 13
```


# Инкремент и декремент

`a++` - постфиксный инкремент - увелечение переменной на 1 и возвращение того, что было
`++a` - префиксный инкремент - увелечение перменной на 1 и возвращение того, что получилось

соответственно, 
`a++` - `rvalue`
`++a` - `lvalue`

`a--` - постфиксный декремент - уменьшение переменной на 1 и возвращение того, что было
`--a` - префиксный декремент - уменьшение перменной на 1 и возвращение того, что получилось

соответственно, 
`a--` - `rvalue`
`--a` - `lvalue`

Инкремент требует, чтобы его аргумент был `lvalue`.
```cpp
++(x = 5);
```

По стандарту, постфиксные операции приоритетней префиксного.

# Тернарный оператор и его особенности

Тернарный - арность равна 3.
Берет левый аргумент, кастует его к `bool`:
1. если истина - вычисляет средний аргумент и возвращает его
2. если ложь - вычисляет правый аргумент и возвращает его

```cpp
x ? y : z
```

Вид `value`, как и тип выражения, должен быть известен на этапе компиляции.
Поэтому ниже - гарантированная ошибка:
```cpp
bool b;
(b ? a++ : ++a) = 1;
```


```cpp
double f(b ? 1 : 0.5);  // в данном случае на выходе будет double
int f(b ? 1 : 0.5)
```
Выберется версия для double.

# Оператор запятая

`(a, b)` - берет `a`, только после того как закончил вычислять `a`, вычисляет `b`, и возвращает `b`. Соответственно, вид `value` будет такой же, как был у `b`.
```cpp
(a, b) = 1;  // если b имеет вид lvalue, то ошибки не будет
```

Не всякая запятая, как символ, является оператором.

```cpp
void f(int x, int y);  
```
Тут нет оператора запятая, так как слева и справа стоят не `expressions`. Это `declaration`, а не `expression`.

# оператор  `sizeof()`

```cpp
int a;
sizeof(a);
```

# Приоритет операторов

`Operator Precedence`

https://en.cppreference.com/w/cpp/language/operator_precedence.html

# Правила sequence before для порядка вычислений

`sequence before` - ассиметричное транзитивное бинарное отношение между вычислениями внутри одного потока.

# Control statements

```cpp
int main() {	
	if (/* bool-expression */) {
		
	} else if (...) {
	
	} else {
	
	}
}
```

```cpp
switch (/* bool-expression */) {
	case 1:
		std::cout << "a";
		break;
	case 2:
		std::cout << "b";
	default: // выполняется, если ни один из case выше не сработал
		std::cout << "c";
}
```

`switch` предпочительней `if`, так как лучше оптимизируется при большом количестве `case`.

```cpp
int main() {
	while () {
		
	}
	
	do {
	
	} while ();
	
	for (/* инициализатор */ ; /* условие */ ; /* итерация */) {
	
	}
	
	for (declaration | expression; bool_expression; expression) {}
}
```


здесь `=` - это не оператор присваивания. Это спициальный символ, обозначающий инициализацию.
```cpp
int x = 0;  
```

в `if` можно делать `declaration`, начиная с C++17:
```cpp
if (int x = 0; y > x) {}
```

в `for` можно не писать какие-то из частей
```cpp
for ( ; ; ) {  // бесконечный цикл

}
```

Есть два важных `control statements`: это `break` и `continue`.

Ключевое слово, и управляющая конструкция - `goto`.
```cpp
label:
	++x;
	std::cout << x;
	goto label;
```
По `codestyle` не рекомендуется писать `goto`, но есть ситуации, когда это полезно.

Еще есть управляющая конструкция `try catch`.