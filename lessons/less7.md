
`RAM` - random-access memory (оперативная память). В ней выделяется кусочек памяти для работы программы. При обращении к памяти за этим будет 
`seg fault`. 
Этот кусочек памяти можно разделить на:
1. text - бинарный код программы
2. data -  `static memory` (статическая память), в ней хранится информация на протяжении всего времени работы программы
3. stack - `automatic memory`, здесь хранятся локальные переменные, объявления функций и тд.

```cpp
#include <iostream>

void f(int y) {
	std::cout << y + 1;
}

int main() {
	int x = 5;
	f(x);
	// другой код
}
```

В `stack`, перед `int y`, пойдет адрес следующей инструкции, которая была после вызова `f` - адрес возврата.
Это лишь первое приближение того, как оно хранится на самом деле.
В запускаемом бинарнике прописано, сколько памяти выделить на `data`, далее операционная система загружает `text` и выделает 8Мб на стек.

Размер стека фиксирован и по умолчанию равен примерно 8Мб. 
У любой программы есть стек. Что будет, если стек переполнится?
Будет `stack overflow`. 
Пример:
```cpp
#include <iostream>
void f(int x) {
	std::cout << ++x << '\n';
	f(x);
}

int main() {
	f(0);
}
```

Когда происходит `stack overflow`, возникает `seg fault`.

```cpp
#include <iostream>

int x = 0;
void f() {
	std::cout << ++x << '\n';
	f();
}

int main() {
	f();
}
```

Тоже переполнение, так как нужно хранить адрес возврата на каждую функции.

`Dynamic memory` может быть запрошена и освобождена в `RunTime`.

```cpp
int* p = new int;
```

```cpp
int* p = new int(5);
```
`new int` - `expression`, программа в этот момент попросит из `dynamic memory` память размера `sizeof(int)`, и вернется указатель на первый байт из тех, что запросили.
При этом сам `p` лежит на стеке.
```cpp
delete p;
```
`delete p` отчищает память. 

```cpp
int* pa = new int[10000];
delete[] pa;
```

```cpp
int* pa = new int[10000]{};  // инициализация нулями
```

Если выйти из зоны видимости, где лежит `p`, указатель уйдет со стека и не получится сделать `delete p`. Это будет `memory lick` (утечка памяти).

В data можно хранить статические переменные:
```cpp
#include <iostream>

void f() {
	static int x = 0;  // local static variable
	std::cout << ++x << '\n';
	f();
}

int main() {
	f();
}
```