Сложные объявления (C-style)
```cpp
#include <iostream>

int main() {
	int* a[10];  // массив из 10 указателей на int
	int (*b)[10];  // указатель на массив из 10 int
	void (*pf)(int); // указатель на функцию, которая принимает int и возвращает void
	
	void (*pfa[10])(int);  // массив из 10 указателей на функцию, которая принимает int и возвращает void
	
	void (*(*pff[10])(int))(int); // Массив из 10 указателей на функцию, которая принимает int и возвращает указатель на функцию, которая принимает int и возвращает void
}
```

Как читать эти объявления? 
Правило: `go right when you can, go left when you must`.

`Abstract declarators` используются в `cast` и в `sizeof()`:
```cpp
int (*(*)())()  // int (*(*foo)())()
```


## Ссылки (`References`)

```cpp
void f(int& y) {
	++y;
}

int main() {

	int x = 5;
	int& y = x;
	f(x);
}
```


2 разных объекта:
```cpp
std::string s = "abc";
std::string s2 = s;
```

1 объект, 2 имени:
```cpp
std::string s = "abc";
std::string& s2 = s;
```

---

```cpp
int x = 5;
int& y = x;
int& t = y;
```
`y` и `x` - два названия одного и того же.


```cpp
void f(int x) {
	++x;
}

void f(int& y) {
	++y;
}

int main() {
	int x = 5;
	int& y = x;
	f(x);    // CE: ambiguous call
	f(y);
}
```

`swap` без использования указателей:
```cpp
void swap(int& x, int& y) {
	int t = x;
	x = y;
	y = t;
}
```

Важно различать (C++ очень удобный):
1. `&x` - унарный амперсанд, возвращающий указатель, является адресом переменной x
2. `*p` - оператор `*`, который по указателю возвращает исходную переменную
3. `int*` - тип, обозанчающий указатель на переменную, является результатом операции `&x`
4. `int&` - тип, обозначающий ссылку на `int`, и он никак не связан с 3 предыдущими

На что будет ссылаться непроинициализированная ссылка? 
```cpp
int& r;  // CE 
```

Ссылку важно проинициализовать `lvalue`:
```cpp
int& r = 5;  // CE
```

```cpp
int x = 5;
int& r = x++;  // CE
int& r = ++x;  // так можно
```

```cpp
int x = 5;
int* p = &x;
```
Строго говоря, возвращаемый тип у `*p` и у `++x` будет `int&`, как и у присваивания `=`.

```cpp
int& g(int& x) { return ++x; }  // функция возвращает lvalue-ссылку

int main() {
	int x = 0;
	g(x) = 6;
	
	int t = g(x);  // lvalue-to-rvalue convertion
}
```

Ссылку на ссылку создать нельзя, нет такого типа.

`int&&` - это особый вид ссылок (`rvalue` ссылка, один из ключевых моментов `move semantics`).

Битая ссылка(`dangling reference`)
```cpp
int& f(int& x) {
	int y = ++x;
	return y;
}

int main() {
	int x = 0;
	int& y = f(x);  // UB
}
```

---

```cpp
int& f() {
	static int y = 0;
	return y;
}

int main() {
	int x = 0;
	int& y = f(x);
}
```

```cpp
int& g() {
	int* p = new int(1);
	return *p;  // return p; - CE
}

int main() {
	int& x = g();  // int x = g(x); - seg fault
	delete &x;
}
```

--- 

Можно ли создать ссылку на указатель?
```cpp
int x = 0;
int* p = &x;

int*& p2 = p;
p = new int(5);
delete p2;  // все корректно, p и p2 - взаимозаменяемые
```
Можно.

---
Можно ли создать указатель на ссылку? Такого типа не бывает.
Но можно сделать так:
```cpp
int& y = x;
&y;  // указатель на int, но не на int&
```

---
Ссылка на массив
```cpp
int a[10];
int(&b)[10] = a;  // b - ссылка на массив a
```

---

Массив из ссылок нельзя создать, его не проинициализировать.
vector из int& тоже не создать, потому что vector в себе хранит указатель.

---

```cpp
void f(int);
int main() {
	void (&g)(int) = f;  // ссылка на функцию f
}
```

---

```cpp
int& f(int); // функция, которая принимает int и возвращает ссылку на int
int (&f)(int);  // ссылка на функцию, которая принимает int и возвращает int
```